### Операторы сравнения(Comparisons operators)

- `terminalogy`

**comparisons operators**

- equal - `==`
- not equal - `!=`
- strict equal - `===`
- strict not equal - `!==`
- greater than - `>`
- greater than or equal - `>=`
- less than - `<`
- less than or equal - `<=`

> Результат сравнения имеет логический тип
> Все операторы сравнения возвращают значение логического типа:

- true – означает «да», «верно», «истина».
- false – означает «нет», «неверно», «ложь».

**Сравнение одинаковых типов**

работает как обычно

- если `number` то у кого больше значения там и true
- если `string` то у кого больше index по unicode там и true
- если `boolean` то у кого true там и true :)

**Сравнение разных типов**

При сравнении значений разных типов JavaScript приводит каждое из них к `number`.

        alert( '2' > 1 ); // true, строка '2' становится числом 2
        alert( '01' == 1 ); // true, строка '01' становится числом 1
        alert( true == 1 ); // true, true становится числом 1
        alert( false == 0 ); // true, false становится 0

Есть два варианта сравнивания:

- сравниваем сразу между разными типами
- сначала преобразуем в один из типов и потом сравниваем

в чем разница ?

- сравним сразу разные типы без преобразования где за нас сам js сделает и преобразует в тип `number`
- преобразуем разные типы в boolean и потом сравним.

            let a = 0;
            let b = "0";
            a == b // true, переменная b преобразуется в `number` и значения будет 0 
            
            let aB = Boolean(a) //false, переменная a в boolean это false  
            let bB = Boolean(b) // true, переменная b в boolean это true
            aB == bB // false 

Как мы видим разные ответы получаем в зависимости какой тип преобразования использовать в сравнениях

Мы можем сами изначально определить по какому типу преобразования будем работать при сравнении, либо работаем по логике
js где он сам преобразуется в тип `number`

**Строгое сравнение**(перевод)

для строго неравенства используется `===`

если будем сравнивать разные типы будет всегда `false`,
так как он проверяет для начало сами типы если типы разные значит `false`

**Сравнение с null и undefined**

как мы знаем преобразования null к `number` равен 0, `Number(null)`
но тут есть одна загвоздка

        Number(undefined) NaN
        Number(null) // 0
        null == 0 // false, хотя должен был ответ быть true так как null станвится 0 и 0 == 0 должен дать true
        null >= 0 // true

к этому случаю есть исключения:

- для нестрогого равенства == значений `undefined` и `null` действует особое правило: эти значения ни к чему не
  приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0 ложно.
